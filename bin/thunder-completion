#!/usr/bin/env ruby

require 'thunder'
require 'erb'

def thunder_commands(bolt)
  bolt[:commands].map(&:first).map(&:to_s)
end

def thunder_options(command)
  return nil unless command[:options]

  result = []
  command[:options].each do |opt, option|
    result << "--#{opt}"
    next unless option[:short]
    result << "-#{option[:short]}"
  end
  return result
end

module Thunder
  def start(args=ARGV.dup, options={})
    template = ERB.new <<-TEMPLATE, nil, "%"
#!/bin/bash

% progname = File.basename(ARGV.first)
__<%= progname %>_commands() {
    echo "<%= thunder_commands(thunder).join(" ") %>"
}
% thunder[:commands].each do |name, command|
%   name = name.to_s
%   if command[:options]

__<%= progname %>_<%= name %>_options() {
    echo "<%= thunder_options(command).join(" ") %>"
}
%   end
% end

__<%= progname %>_complete() {
  local words=""
    if [[ ${COMP_WORDS[COMP_CWORD]:0:1} == "-" ]]; then
        if ((COMP_CWORD == 1)); then
            words=
        else
            local command="__<%= progname %>_${COMP_WORDS[1]}_options"
            words=$($command)
        fi
    elif ((COMP_CWORD == 1)); then
        # display only commands
        words=$(__<%= progname %>_commands)
    fi
    COMPREPLY=($(compgen -W "$words" -- ${COMP_WORDS[COMP_CWORD]}))
}

complete -o default -o nospace -F __<%= progname %>_complete <%= progname %>

    TEMPLATE
    context = (proc { |thiz, thunder|
      binding
    }).call(self, self.class.thunder)
    puts template.result(context)
  end
end

if ARGV.size != 1
  puts "Usage: thunder-completion THUNDER_SCRIPT"
  puts
  puts "Prints out the suggested template for a bash completion script for the given thunder script"
  exit 1
end

load File.expand_path(ARGV.first)
